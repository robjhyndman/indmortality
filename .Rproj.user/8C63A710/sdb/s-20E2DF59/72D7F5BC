{
    "collab_server" : "",
    "contents" : "# Create table of total deaths for a specific state/sex combination\n\n#' Function to make deaths tables for subsets of data.\n#' \n#' Returns array with ages and years and (depending on the arguments) states,\n#' sex and cut. Default arguments will return the complete array. Use the\n#' argument to specify subsets of the array. Uses all available years unless\n#' aveyear=TRUE, in which case it will return average deaths across years.\n#' \n#' \n#' @param state If \"ALL\", the function will return all deaths with state as a\n#' dimension of the array. Otherwise the function will return all deaths from\n#' the state indicated but with state not a dimension of the array.\n#' @param sex If \"ALL\", the function will return all deaths with sex as a\n#' dimension of the array. Otherwise the function will return all deaths from\n#' the sex indicated but with sex not a dimension of the array.\n#' @param cut If \"ALL\", the function will return all deaths with state as a\n#' dimension of the array. Otherwise the function will return all deaths from\n#' the state indicated but with state not a dimension of the array.\n#' @param year Which years to be returned. Default is all available years.\n#' years is always a dimension of the returned array.\n#' @param upper.age Deaths are cumulated for higher ages into this upper age\n#' group.\n#' @param aveyear If TRUE, the deaths are averaged across years.\n#' @param deaths Matrix containing all deaths with indigenous classification in\n#' Australia from 2001-2007 in the same format as \\code{\\link{deaths}}.\n#' @param cumulative Indicates if the deaths are to be cumulated up to the\n#' specified \"cut\", or whether the marginal deaths associated with that cut are\n#' to be returned.\n#' @return A numerical array with death counts in each cell. Dimensions of the\n#' array are age, year and then (depending on the arguments) state,sex,cut.\n#' @author Rob J Hyndman <Rob.Hyndman@@monash.edu>\n#' @references Choi, C., Hyndman, R.J., Smith, L., and Zhao, K. (2010) \\emph{An\n#' enhanced mortality database for estimating indigenous life expectancy}.\n#' Report for Australian Institute of Health and Welfare.\n#' @examples\n#' \n#' tab1 <- deathstable(sex=\"female\")\n#' tab2 <- deathstable(state=\"VIC\", cut=\"H\", aveyear=TRUE)\n#' tab3 <- deathstable()\n#' \n#' @export\ndeathstable <- function(\n  state=c(\"AUS\",\"ACT\",\"NSW\",\"NT\",\"QLD\",\"SA\",\"TAS\",\"VIC\",\"WA\"),\n  sex=c(\"female\",\"male\",\"total\"),\n  linked=c(NA,TRUE,FALSE),\n  classified=c(NA,\"N\",\"Y\",\"U\"),\n  year=NULL,\n  aveyear=FALSE,\n  upper.age=100,\n  cumulative=TRUE,\n  deaths=indmortality::ideaths)\n{\n  state <- match.arg(state)\n  sex <- match.arg(sex)\n  maxage <- max(deaths$Age,na.rm=TRUE)\n\n  # Subset on year\n  nyear <- deaths$RegYear\n  dyear <- sort(unique(nyear))\n  if(is.null(year))\n    year <- dyear\n  else if(sum(!is.element(year,dyear)) > 0)\n    warning(\"Some years unavailable\")\n  deaths <- subset(deaths,is.element(nyear,year))\n  deaths$Year <- as.factor(deaths$RegYear)\n\n  # Subset on state\n  if(state != \"AUS\")\n    deaths <- subset(deaths,deaths$State==state)\n\n  # Subset on sex\n  if(sex==\"male\")\n    deaths <- subset(deaths,deaths$Sex==\"M\")\n  else if(sex==\"female\")\n    deaths <- subset(deaths,deaths$Sex==\"F\")\n\n  # Subset on linked\n  if(!is.na(linked))\n  {\n    if(linked)\n      deaths <- subset(deaths, deaths$LinkStatus==\"Linked\")\n    else\n      deaths <- subset(deaths, deaths$LinkStatus==\"Unlinked\")\n  }\n\n  # Subset on indigenous status\n  if(!is.na(classified))\n    deaths <- subset(deaths, deaths$Indigenous==classified)\n\n  if(nrow(deaths)==0)\n    stop(\"No deaths selected\")\n\n  # Make age a factor\n  deaths$age1 <- factor(deaths$Age, exclude=NULL, levels=c(paste(0:maxage),\"missing\"))\n  deaths$age1[is.na(deaths$age1)] <- \"missing\"\n\n\n  # Sum up data where age is not missing\n  tab <- xtabs(~ age1 + Year + Sex + State, data = deaths)\n\n  if(state!=\"AUS\")\n    tab <- tab[,,,state,drop=FALSE]\n  if(sex==\"male\")\n    tab <- tab[,,\"M\",,drop=FALSE]\n  else if(sex==\"female\")\n    tab <- tab[,,\"F\",,drop=FALSE]\n\n  tab <- apply(tab,2:length(dim(tab)),distribute.deaths.vec)\n\n  # Aggregate upper ages\n  if(upper.age < maxage)\n  {\n    tab[upper.age+1,,,] <- apply(tab[(upper.age:maxage)+1,,,,drop=FALSE],2:4,sum)\n    tab <- tab[1:(upper.age+1),,,,drop=FALSE]\n    maxage <- upper.age\n  }\n  dimnames(tab)[[1]][maxage+1] <- paste(dimnames(tab)[[1]][maxage+1],\"+\",sep=\"\")\n\n  # Collapse results if required\n  dnames <- names(dimnames(tab)) <- c(\"Age\",\"Year\",\"Sex\",\"State\")\n  if(sex==\"total\")\n  {\n    dnames <- dnames[dnames!=\"Sex\"]\n    tab <- apply(tab,dnames,sum)\n  }\n  if(state==\"AUS\")\n  {\n    dnames <- dnames[dnames!=\"State\"]\n    tab <- apply(tab,dnames,sum)\n  }\n  if(aveyear)\n  {\n    dnames <- dnames[dnames!=\"Year\"]\n    tab <- apply(tab,dnames,mean)\n  }\n\n  # Add pro-rata deaths due to missing ages\n\n\n  # Remove dimensions of length 1\n  dl <- dim(tab)\n  tab <- apply(tab,which(dl>1),function(x){x})\n\n  # Return resulting table\n  return(tab)\n}\n\n# Find all deaths associated with missing ages and distribute across ages\n# according to existing age distribution\n# This assumes age missing at random\ndistribute.deaths.vec <- function(x)\n{\n  miss <- names(x)==\"missing\"\n  sumx <- sum(x[!miss])\n  if(sumx > 0)\n    x[!miss] <- x[!miss] * sum(x)/sumx\n  return(x[!miss])\n}\n",
    "created" : 1494476141355.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1395553034",
    "id" : "72D7F5BC",
    "lastKnownWriteTime" : 1494474922,
    "last_content_update" : 1494476146539,
    "path" : "~/git/R/indmortality/R/dtable.R",
    "project_path" : "R/dtable.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}