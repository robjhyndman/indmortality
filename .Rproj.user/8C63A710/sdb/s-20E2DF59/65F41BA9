{
    "collab_server" : "",
    "contents" : "#' Make demogdata objects for particular states and years.\n#' \n#' The function \\code{make.demogdata} will return a demogdata object if\n#' \\code{cut!=\"ALL\"}. Otherwise it returns a list of demogdata objects for all\n#' cuts for a particular state.\n#' \n#' If there are more years of deaths than years of population, then the last\n#' year of available population data is used to compute the rates for\n#' subsequent years.\n#' \n#' @param state Character code indicating state or territory of Australia, or\n#' \"AUS\" indicating the whole of Australia.\n#' @param sex If \"ALL\", the function will return all sexes as part of each\n#' demogdata object. Otherwise the function will return only the sex indicated.\n#' @param cut Which cut of data to use. If \"ALL\", then a list of demogdata\n#' objects is returned.\n#' @param year Years to include in the demogdata object. The default is to\n#' include all available years from the deaths matrix.\n#' @param aveyear Logical value indicating whether results should be averaged\n#' across years. Default is FALSE.\n#' @param upper.age Upper age group, by default set to 100+.\n#' @param smooth Logical value indicating whether mortality rates should be\n#' smoothed using penalized regression splines. Default is TRUE.\n#' @param deaths A matrix containing all unit death records in the form of\n#' \\code{\\link{ideaths}}.\n#' @param pop A list of list of matrices containing population numbers. This\n#' should be in the form of \\code{\\link{ipop}}.\n#' @return A demogdata object (if \\code{cut!=\"ALL\"}) or a list of demogdata\n#' objects (if \\code{cut==\"ALL\"}). See \\link[demography]{demogdata} for more\n#' information about demogdata objects.\n#' @author Rob J Hyndman <Rob.Hyndman@@monash.edu>\n#' @references Choi, C., Hyndman, R.J., Smith, L., and Zhao, K. (2010) \\emph{An\n#' enhanced mortality database for estimating indigenous life expectancy}.\n#' Report for Australian Institute of Health and Welfare.\n#' @examples\n#' \n#' nsw.M <- make.demogdata(state=\"NSW\",cut=\"M\")\n#' plot(nsw.M, \"female\")\n#' \n#' # Show smoothing\n#' test <- make.demogdata(state=\"NSW\", cut=\"M\", sex=\"female\", smooth=FALSE)\n#' test.sm <- smooth.demogdata(test)\n#' plot(test, year=2006, type=\"p\", pch=1)\n#' lines(test.sm, year=2006, col=\"red\")\n#' \n#' @export\nmake.demogdata <- function(state=c(\"AUS\",\"ACT\",\"NSW\",\"NT\",\"QLD\",\"SA\",\"TAS\",\"VIC\",\"WA\"),\nsex=c(\"ALL\",\"female\",\"male\",\"total\"), cut=c(\"ALL\",\"M\",\"H\",\"A\",\"N\"),\n    year=NULL, aveyear=FALSE, upper.age=100, smooth=TRUE, deaths=indmortality::ideaths, pop=indmortality::ipop)\n{\n  cut <- match.arg(cut)\n  state <- match.arg(state)\n  sex <- match.arg(sex)\n  if(cut!=\"ALL\")\n    return(make.demogdata.cut(deaths,pop,state,sex,cut,year,upper.age,smooth,aveyear))\n  # Otherwise continue with all cuts\n  out <- list()\n  cut <- c(\"M\", \"H\", \"A\", \"N\")\n  for(i in 1:length(cut))\n    out[[i]] <- make.demogdata.cut(deaths,pop,state,sex,cut[i],year,upper.age,smooth,aveyear)\n  if(smooth) # Check rates increase with more deaths data. Should happen anyway for non-smoothed data\n  {\n    for(j in 1:length(out[[1]]$rate))\n      for(i in 2:length(cut))\n        out[[i]]$rate[[j]] <- pmax(out[[i-1]]$rate[[j]],out[[i]]$rate[[j]])\n  }\n  names(out) <- cut\n  return(structure(out,class=\"gdemogdata\"))\n}\n\n#' @export\nmake.demogdata.cut <- function(deaths, pop, state=c(\"NSW\",\"VIC\",\"QLD\",\"WA\",\"SA\",\"TAS\",\"ACT\",\"NT\",\"AUS\"),\n    sex=c(\"ALL\",\"female\",\"male\",\"total\"), cut=c(\"M\", \"H\", \"A\", \"N\"), year=NULL, upper.age=100, smooth=TRUE, aveyear=FALSE)\n{\n  state <- match.arg(state)\n  cut <- match.arg(cut)\n  sex <- match.arg(sex)\n\n  # Check years required and available\n  availableyears <- sort(unique(as.numeric(as.character(deaths$Year))))\n  if(is.null(year))\n    year <- availableyears\n  else\n    year <- year[is.element(year,availableyears)]\n\n  # Get male deaths and pop\n  if(sex!=\"female\")\n  {\n    mdeaths <- as.matrix(deathstable(state, \"male\",   cut, year, aveyear, upper.age, deaths=deaths))\n    upper.age <- nrow(mdeaths)-1\n    mpop <- pop[[state]][[\"male\"]]\n    if(upper.age < nrow(mpop)-1)\n      mpop <- rbind(mpop[1:upper.age,,drop=FALSE],colSums(mpop[(upper.age+1):nrow(mpop),,drop=FALSE]))\n    else\n    {\n      upper.age <- nrow(mpop)-1\n      if(upper.age < nrow(mdeaths)-1)\n        mdeaths <- rbind(mdeaths[1:upper.age,,drop=FALSE],colSums(mdeaths[(upper.age+1):nrow(mdeaths),,drop=FALSE]))\n    }\n    ppop <- mpop\n  }\n  # Get female deaths and pop\n  if(sex!=\"male\")\n  {\n    fdeaths <- as.matrix(deathstable(state, \"female\", cut, year, aveyear, upper.age, deaths=deaths))\n    upper.age <- nrow(fdeaths)-1\n    fpop <- pop[[state]][[\"female\"]]\n    if(upper.age < nrow(fpop)-1)\n      fpop <- rbind(fpop[1:upper.age,,drop=FALSE],colSums(fpop[(upper.age+1):nrow(fpop),,drop=FALSE]))\n    else\n    {\n      upper.age <- nrow(fpop)-1\n      if(upper.age < nrow(fdeaths)-1)\n        fdeaths <- rbind(fdeaths[1:upper.age,,drop=FALSE],colSums(fdeaths[(upper.age+1):nrow(fdeaths),,drop=FALSE]))\n    }\n    ppop <- fpop\n  }\n  # Get total deaths\n  if(sex==\"ALL\" | sex==\"total\")\n    tdeaths <- mdeaths + fdeaths\n\n  # Assume last year population for all subsequent years\n  pyear <- as.numeric(colnames(ppop))\n  pyear <- c(pyear,max(pyear)+(1:50))\n  j <- pmin(ncol(ppop),which(is.element(pyear,year)))\n  if(aveyear)\n    year <- mean(year)\n\n  # Get female rates\n  if(sex!=\"male\")\n  {\n    fpop <- fpop[,j,drop=FALSE]\n    if(aveyear)\n      fpop <- matrix(rowMeans(fpop),ncol=1)\n    frate <- as.matrix(fdeaths/fpop)\n    rownames(frate) <- rownames(fpop) <- paste(0:upper.age,c(rep(\"\",upper.age),\"+\"),sep=\"\")\n  }\n  # Get male rates\n  if(sex!=\"female\")\n  {\n    mpop <- mpop[,j,drop=FALSE]\n    if(aveyear)\n      mpop <- matrix(rowMeans(mpop),ncol=1)\n    mrate <- as.matrix(mdeaths/mpop)\n    rownames(mrate) <- rownames(mpop) <- paste(0:upper.age,c(rep(\"\",upper.age),\"+\"),sep=\"\")\n  }\n  # Get total pop and rates\n  if(sex==\"ALL\" | sex==\"total\")\n  {\n    tpop <- fpop+mpop\n    trate <- as.matrix(tdeaths/tpop)\n    rownames(trate) <- rownames(tpop) <- paste(0:upper.age,c(rep(\"\",upper.age),\"+\"),sep=\"\")\n  }\n\n  # Construct demogdata object\n  if(sex==\"female\")\n    cut <- demogdata(frate,fpop,ages=0:upper.age,years=year,\n      type=\"mortality\",label=paste(\"Indigenous\",state,cut),name=\"female\",lambda=0)\n  else if(sex==\"male\")\n    cut <- demogdata(mrate,mpop,ages=0:upper.age,years=year,\n      type=\"mortality\",label=paste(\"Indigenous\",state,cut),name=\"male\",lambda=0)\n  else\n    cut <- demogdata(trate,tpop,ages=0:upper.age,years=year,\n      type=\"mortality\",label=paste(\"Indigenous\",state,cut),name=\"total\",lambda=0)\n\n  if(sex==\"ALL\")\n  {\n    cut$rate$female <- frate\n    cut$rate$male <- mrate\n    cut$rate$total <- trate\n    cut$pop$female <- fpop\n    cut$pop$male <- mpop\n    cut$pop$total <- tpop\n  }\n\n  # Smooth rates\n  if(smooth)\n  {\n    smoothcut <- try(smooth.demogdata(cut,b=30,k=30), silent=TRUE)\n    if(class(smoothcut)==\"try-error\")\n    {\n      smoothcut <- try(smooth.demogdata(cut,b=30,k=20), silent=TRUE)\n      if(class(smoothcut)==\"try-error\")\n      {\n        smoothcut <- try(smooth.demogdata(cut,b=30,k=10), silent=TRUE)\n        if(class(smoothcut)==\"try-error\") # Give up\n        {\n          warning(\"Not enough available data to do any smoothing\")\n          smoothcut <- cut\n        }\n      }\n    }\n    return(smoothcut)\n  }\n  else\n    return(cut)\n\n}\n\n",
    "created" : 1494476274375.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3898269333",
    "id" : "65F41BA9",
    "lastKnownWriteTime" : 1494475693,
    "last_content_update" : 1494475693,
    "path" : "~/git/R/indmortality/R/make.demogdata.R",
    "project_path" : "R/make.demogdata.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}